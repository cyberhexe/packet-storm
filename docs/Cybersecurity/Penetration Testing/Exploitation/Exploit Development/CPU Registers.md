## CPU Registers

- http://spike.scu.edu.au/~barry/80x86_inst.html#RET
- https://wiki.skullsecurity.org/Registers#eax

The CPU registers help to store program variables and data as the program runs.
Registers are small, extremely high-speed CPU storage locations where data can be efficiently read or manipulated.

Several registers such as `EAX`, `EBX`, `ECX`, `EDX`, `ESI`, and `EDI` are often used as general purpose registers to store temporary data. There is much more to this discussion (as explained in various online resources), but the primary registers for our purposes are described below:

- `EAX (the accumulator)` - Arithmetical and logical instructions
- `EBX (base)` - Base pointer for memory addresses
- `ECX (the counter)` - Loop, shift, and rotation counter
- `EDX (data)` - I/O port addressing, multiplication, and division
- `ESI (the source index)` - Pointer addressing of data and source in string copy operations
- `EDI (the destination index)` - Pointer addressing of data and destination in string copy operations
- `ESP (the stack pointer)` - The Extended Stack Pointer Register most commonly points to the top of the running processes stack allowing to program to push or pop values from the stack
- `EIP (the instruction pointer)` - The Extended Instruction Pointer Register holds the current address location for the instruction being executed at any given time. The `EIP` Register controls the path of code execution of a program.

A pointer is a reference to an address (or location) in memory. When we say a register "stores a pointer" or "points" to an address, this essentially means that the register is storing that target address.

## ESP - The Stack Pointer

The stack is used for storage of data, pointers and arguments. 
Since the stack is dynamic and changes constantly during program execution, the stack pointer ESP keeps "track" of the most recently referenced location on the stack (top of the stack) by storing a pointer to it.

## EBP - The Base Pointer

Since the stack is in a constant flux during the execution of a thread, it can become difficult for a function to locate its stack frame, which stores the required arguments, local variables, and the return address.
`EBP`, the base pointer, solves this by storing a pointer to the top of the stack when a function is called.
By accessing `EBP`, a function can easily reference information from its stack frame (via offsets) while executing.

In other words, `EBP` points to the location of the stack frame in memory.

## EIP - The Instruction Pointer

- https://web.archive.org/web/20131017021753/http://skypher.com/wiki/index.php/Hacking/Shellcode/GetPC

`EIP`, the instruction pointer, is one of the most important registers for our purposes as it always points to the next code instruction to be executed.
Since `EIP` essentially directs the flow of a program, it is an attacker's primary target when exploiting any memory corruption vulnerability such as a buffer overflow.

A fast way to identify the location of the `EIP` starts with inserting a long string made of non-repeating 4-byte chunks as our input. 
Then, when the `EIP` is overwritten with four bytes from our string, we can use that unique sequence to pinpoint the exact location.

## FZ - The Zero Flag Register

The Zero Flag register is a single bit flag that is used on most architectures.
On x86/x64, it is stored in a dedicated register called `ZF`.
This flag is used to check the result of arithmetic operations. It is set to 1 (TRUE) if the result of an arithmetic operation is zero and otherwise set to 0 (FALSE).

