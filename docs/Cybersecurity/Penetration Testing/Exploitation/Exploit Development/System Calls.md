## General Information

- https://en.wikipedia.org/wiki/System_call

System calls (syscalls) are a set of powerful functions that provide an interface to the protected kernel from user space.
This interface allows access to low-level operating system functions used for I/O, thread synchronization, socket management, and more.
Practically speaking, syscalls allow user applications to directly access the kernel while ensuring they don't compromise the OS.

Generally speaking, the purpose of any shellcode is to conduct arbitrary operations that are not part of the original application code logic.
In order to do so, the shellcode uses assembly instructions that invoke system calls after the exploit hijacks the application's execution flow.

Kernel-level functions are typically identified by system call numbers that are used to call the corresponding functions.
It is important to note that on Windows, these system call numbers tend to change between major and minor version releases.
On Linux systems however, these call numbers are fixed and do not change.
We should also keep in mind that the feature set exported by the Windows system call interface is rather limited.
For example, Windows does not export a socket API via the system call interface.
This means we need to avoid direct system calls to write universal and reliable shellcode for Windows.

## Windows X86 Syscalls

- https://social.technet.microsoft.com/wiki/contents/articles/11831.the-windows-native-api.aspx
- https://en.wikipedia.org/wiki/Windows_Native_API

The Windows Native API is equivalent to the system call interface on UNIX operating systems.
It is a mostly-undocumented application programming interface exposed to user-mode applications by the `ntdll.dll` library.
As such, it provides a way for user-mode applications to call operating system functions located in the kernel in a controlled manner.

On most UNIX operating systems, the system call interface is well-documented and generally available for user applications. 
The Native API, in contrast, is hidden behind higher-level APIs due to the nature of the NT architecture.

The Native API supports a number of operating system APIs (`Win32`, `OS/2`, `POSIX`, `DOS/Win16`) by implementing operating environment subsystems in user-mode that export particular APIs to client programs.


## Using Windows API

- https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya
- https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea
- https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress

Without system calls, our only option for communicating directly with the kernel is to use the Windows API, which is exported by dynamic-link libraries (DLLs) that are mapped into process memory space at runtime. 
If DLLs are not already loaded into the process space, we need to load them and locate the functions they export. 
Once the functions have been located, we can invoke them as part of our shellcode in order to perform specific tasks.

Fortunately, `kernel32.dll` exposes functions that can be used to accomplish both of these tasks, and is likely to be mapped into the process space.

The `LoadLibraryA` function implements the mechanism to load DLLs, while `GetModuleHandleA` can be used to get the base address of an already-loaded DLL. 
Afterward, `GetProcAddress` can be used to resolve symbols.

Unfortunately, the memory addresses of `LoadLibrary` and `GetProcAddress` are not automatically known to us when we want to execute our shellcode in memory.
For our shellcode to work, we will need to find another way to obtain the base address of `kernel32.dll`. 
Then, we'll have to figure out how to resolve various function addresses from `kernel32.dll` and any other required DLLs. 
Finally, we will learn how to invoke our resolved functions to achieve various results, such as a reverse shell.


## Finding kernel32.dll

- https://www.offensive-security.com/awe/AWEPAPERS/winasm-1.0.1.pdf

First, our shellcode needs to locate the base address of `kernel32.dll`.
As we mentioned earlier, we need to start with this DLL because it contains all APIs required to load additional DLLs and resolve functions within them, namely `LoadLibrary` and `GetProcAddress`.

To obtain the base address of a DLL, we need to ensure that it is mapped within the same memory space as our running shellcode.
Fortunately, `kernel32.dll` is almost guaranteed to be loaded because it exports core APIs required for most processes, which will significantly increase the portability of our shellcode.

Once we obtain the base address of `kernel32.dll` and can resolve its exported functions, we'll be able to load additional DLLs using `LoadLibraryA` and leverage `GetProcAddress` to resolve functions within them.

There are several methods that can be used to find the `kernel32.dll` base address. They commonly rely on the Process Environmental Block (`PEB`) structure. 
Two other techniques, the Structured Exception Handler (`SEH`) and the `Top Stack` method, are less portable and will not work on modern versions of Windows.


Finding the `ntdll.dll` library within the Notepad memory space:

Dump the thread environment block first:

```text
0:006> dt _TEB @$teb
ntdll!_TEB
   +0x000 NtTib            : _NT_TIB
   +0x01c EnvironmentPointer : (null) 
   +0x020 ClientId         : _CLIENT_ID
   +0x028 ActiveRpcHandle  : (null) 
   +0x02c ThreadLocalStoragePointer : (null) 
   +0x030 ProcessEnvironmentBlock : 0x02b5b000 _PEB
```

Check the process environment block:

```text
0:006> dt _PEB 0x02b5b000 
ntdll!_PEB
... truncated ...
   +0x00c Ldr              : 0x77e6ab40 _PEB_LDR_DATA
```

Fetch the LDR structure to get a linked list of loaded libraries:

```text
ntdll!_PEB_LDR_DATA
   +0x000 Length           : 0x30
   +0x004 Initialized      : 0x1 ''
   +0x008 SsHandle         : (null) 
   +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x2da1d48 - 0x2dbd8e8 ]
   +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x2da1d50 - 0x2dbd8f0 ]
   +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x2da1c70 - 0x2dbe138 ]
   +0x024 EntryInProgress  : (null) 
   +0x028 ShutdownInProgress : 0 ''
   +0x02c ShutdownThreadId : (null) 
```

Get the linked list of loaded libraries:

```text
0:006> dt _LIST_ENTRY 0x77e6ab40 + 0x01c
ntdll!_LIST_ENTRY
 [ 0x2da1c70 - 0x2dbe138 ]
   +0x000 Flink            : 0x02da1c70 _LIST_ENTRY [ 0x2da2448 - 0x77e6ab5c ]
   +0x004 Blink            : 0x02dbe138 _LIST_ENTRY [ 0x77e6ab5c - 0x2dbd798 ]
```

Dump the library's base address of this entry:

```text
0:006> dt _LDR_DATA_TABLE_ENTRY (0x2da1c70 - 0x10)
ntdll!_LDR_DATA_TABLE_ENTRY
   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x2da20e8 - 0x2da1d48 ]
   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x2da20f0 - 0x2da1d50 ]
   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x2da2448 - 0x77e6ab5c ]
   +0x018 DllBase          : 0x77d50000 Void
   +0x01c EntryPoint       : (null) 
   +0x020 SizeOfImage      : 0x190000
   +0x024 FullDllName      : _UNICODE_STRING "C:\Windows\SYSTEM32\ntdll.dll"
   +0x02c BaseDllName      : _UNICODE_STRING "ntdll.dll"
```














