## Calling Conventions

- https://en.wikipedia.org/wiki/Calling_convention

Calling conventions describe how functions receive their parameters from the caller and how they return the result.

The x86 architecture allows for the use of multiple calling conventions. 
The difference in their implementation consists of several factors such as how the parameters and the return value are passed (placed in the CPU registers, pushed on the stack, or both), in which order they are passed, how the stack is prepared and cleaned up before and after the call, and what CPU registers the called function must preserve for the caller.

Generally speaking, the compiler determines which calling convention is used for all functions in a program, however, in some cases, it is possible for the programmer to specify a specific calling convention on a per-function basis.

In other words, calling conventions describe the schema used to invoke function calls.

Specifically, they define:

- How arguments are passed to a function.
- Which registers the callee must preserve for the caller.
- How the stack frame needs to be prepared before the call.
- How the stack frame needs to be restored after the call.


Win32 API functions use the `__stdcall` calling convention, while C runtime functions use the `__cdecl` calling convention.


- https://docs.microsoft.com/en-us/cpp/cpp/stdcall?redirectedfrom=MSDN&view=msvc-170
- https://docs.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-160


For any calling convention on a 32-bit system, the `EAX`, `EDX`, and `ECX` registers are considered volatile, which means they can be clobbered during a function call. 
Therefore, we should not rely on these registers unless we have tested and confirmed that they are not affected during the execution of the called API. 
All other registers are considered non-volatile and must be preserved by the callee.

