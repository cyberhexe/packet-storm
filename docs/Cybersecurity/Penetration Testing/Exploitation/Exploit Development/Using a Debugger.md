## Using a Debugger

A debugger is a computer program inserted between the target application and the CPU, in principle, acting like a proxy.

Using a debugger allows us to view and interact with the memory and execution flow of applications.
The memory space of most operation systems, including Windows, is divided into two parts, kernel mode (ring 0) and user mode (ring 3).

## Debugging Symbols

Symbol files permit to reference internal functions, structures, and global variables using names instead of addresses.

## Using WinDBG

- https://developer.microsoft.com/en-us/windows/hardware/download-windbg
- https://docs.microsoft.com/en-gb/windows-hardware/drivers/debugger/debugging-using-windbg-preview
- http://windbg.info/doc/1-common-cmds.html

Printing help:

```text
0:006> .hh
```

We access the symbol settings through the `File > Symbol File Path...` menu. A commonly used symbol path is `C:\symbols`.

```text
srv*c:\symbols*https://msdl.microsoft.com/download/symbols
```

Reload current modules:

```text
0:006> .reload /f
```

Check if the module is loaded:

```text
0:006> lm m kernel32
Browse full module list
start    end        module name
74ee0000 74f75000   KERNEL32   (deferred)  
```

### Unassemble from memory:

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/u--unassemble-

We can display the assembly translation of a specified program code in memory with the WinDbg `u1` command. 
This is useful as it allows us to inspect the assembly code of certain Windows APIs as well as any part of the code of the current running program.

```text
0:006> u kernel32!GetCurrentThread
KERNEL32!GetCurrentThread:
74f02620 b8feffffff      mov     eax,0FFFFFFFEh
74f02625 c3              ret
74f02626 cc              int     3
74f02627 cc              int     3
74f02628 cc              int     3
74f02629 cc              int     3
74f0262a cc              int     3
74f0262b cc              int     3
```

### Reading from Memory

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/d--da--db--dc--dd--dd--df--dp--dq--du--dw--dw--dyb--dyd--display-memor

We can read process memory content using the `display` command followed by the size indicator.

Display bytes through the `db` command (this uses the ESP register instead of an explicit memory address):

```text
0:006> db esp
0703fa70  f9 9b 35 77 14 38 a2 4e-c0 9b 35 77 c0 9b 35 77  ..5w.8.N..5w..5w
0703fa80  00 00 00 00 74 fa 03 07-00 00 00 00 e8 fa 03 07  ....t...........
0703fa90  90 73 32 77 c8 f9 98 3e-00 00 00 00 b0 fa 03 07  .s2w...>........
0703faa0  64 95 ef 74 00 00 00 00-40 95 ef 74 1b f3 6e de  d..t....@..t..n.
0703fab0  f8 fa 03 07 3c 29 2f 77-00 00 00 00 70 38 a2 4e  ....<)/w....p8.N
0703fac0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
0703fad0  00 00 00 00 00 00 00 00-00 00 00 00 70 38 a2 4e  ............p8.N
0703fae0  bc fa 03 07 00 00 00 00-00 fb 03 07 90 73 32 77  .............s2w
```

Display bytes located at the given address:

```text
0:006> db 0703fae0
0703fae0  bc fa 03 07 00 00 00 00-00 fb 03 07 90 73 32 77  .............s2w
0703faf0  b8 ed 98 3e 00 00 00 00-08 fb 03 07 10 29 2f 77  ...>.........)/w
0703fb00  ff ff ff ff 61 3c 33 77-00 00 00 00 00 00 00 00  ....a<3w........
0703fb10  c0 9b 35 77 00 00 00 00-00 00 00 00 00 00 00 00  ..5w............
0703fb20  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
```

To display data in a larger size format we can use `dw` (WORDs, two bytes together):

```text
0:006> dw esp
0703fa70  9bf9 7735 3814 4ea2 9bc0 7735 9bc0 7735
0703fa80  0000 0000 fa74 0703 0000 0000 fae8 0703
0703fa90  7390 7732 f9c8 3e98 0000 0000 fab0 0703
0703faa0  9564 74ef 0000 0000 9540 74ef f31b de6e
0703fab0  faf8 0703 293c 772f 0000 0000 3870 4ea2
0703fac0  0000 0000 0000 0000 0000 0000 0000 0000
0703fad0  0000 0000 0000 0000 0000 0000 3870 4ea2
0703fae0  fabc 0703 0000 0000 fb00 0703 7390 7732
```

To display DWORDs (four bytes) you can use `dd`:

```text
0:006> dd esp
0703fa70  77359bf9 4ea23814 77359bc0 77359bc0
0703fa80  00000000 0703fa74 00000000 0703fae8
0703fa90  77327390 3e98f9c8 00000000 0703fab0
0703faa0  74ef9564 00000000 74ef9540 de6ef31b
0703fab0  0703faf8 772f293c 00000000 4ea23870
0703fac0  00000000 00000000 00000000 00000000
0703fad0  00000000 00000000 00000000 4ea23870
0703fae0  0703fabc 00000000 0703fb00 77327390
```

Change default length when displaying data:

```text
0:006> dd esp L4
0703fa70  77359bf9 4ea23814 77359bc0 77359bc0

0:006> dd esp L10
0703fa70  77359bf9 4ea23814 77359bc0 77359bc0
0703fa80  00000000 0703fa74 00000000 0703fae8
0703fa90  77327390 3e98f9c8 00000000 0703fab0
0703faa0  74ef9564 00000000 74ef9540 de6ef31b
```

To display QWORDs (eight bytes), we can use `dq`:

```text
0:006> dq esp
0703fa70  4ea23814`77359bf9 77359bc0`77359bc0
0703fa80  0703fa74`00000000 0703fae8`00000000
0703fa90  3e98f9c8`77327390 0703fab0`00000000
0703faa0  00000000`74ef9564 de6ef31b`74ef9540
0703fab0  772f293c`0703faf8 4ea23870`00000000
0703fac0  00000000`00000000 00000000`00000000
0703fad0  00000000`00000000 4ea23870`00000000
0703fae0  00000000`0703fabc 77327390`0703fb00
```

To display memory content in ASCII we can use `dc` or `dW`:

```text
0:006> dc KERNELBASE
73ec0000  00905a4d 00000003 00000004 0000ffff  MZ..............
73ec0010  000000b8 00000000 00000040 00000000  ........@.......
73ec0020  00000000 00000000 00000000 00000000  ................
73ec0030  00000000 00000000 00000000 000000f0  ................
73ec0040  0eba1f0e cd09b400 4c01b821 685421cd  ........!..L.!Th
73ec0050  70207369 72676f72 63206d61 6f6e6e61  is program canno
73ec0060  65622074 6e757220 206e6920 20534f44  t be run in DOS 
73ec0070  65646f6d 0a0d0d2e 00000024 00000000  mode....$.......
0:006> dW KERNELBASE+0x40
73ec0040  1f0e 0eba b400 cd09 b821 4c01 21cd 6854  ........!..L.!Th
73ec0050  7369 7020 6f72 7267 6d61 6320 6e61 6f6e  is program canno
73ec0060  2074 6562 7220 6e75 6920 206e 4f44 2053  t be run in DOS 
73ec0070  6f6d 6564 0d2e 0a0d 0024 0000 0000 0000  mode....$.......
73ec0080  257d 47ae 4439 14c0 4439 14c0 4439 14c0  }%.G9D..9D..9D..
73ec0090  3c30 1453 443d 14c0 4439 14c1 475e 14c0  0<S.=D..9D..^G..
73ec00a0  264a 15c1 443c 14c0 264a 15c5 4429 14c0  J&..<D..J&..)D..
73ec00b0  264a 15c3 4431 14c0 264a 15c4 475c 14c0  J&..1D..J&..\G..
0:006> dW KERNELBASE L5
73ec0000  5a4d 0090 0003 0000 0004                 MZ........
```

Using the `dd` command twice to deference a pointer:

```text
0:006> dd esp L1
0703fa70  77359bf9
0:006> dd 77359bf9
77359bf9  c03307eb 658bc340 fc45c7e8 fffffffe
77359c09  e0e8006a ccfff98d cccccccc cccccccc
77359c19  cccccccc 8bcccccc ec8b55ff 180d8b64
77359c29  8b000000 81890845 00000f24 0004c25d
77359c39  cccccccc 8bcccccc ec8b55ff 0018a164
77359c49  b0ff0000 00000f24 e80875ff fffc49e7
77359c59  0004c25d cccccccc cccccccc cccccccc
77359c69  cccccccc 8bcccccc ec8b55ff 640875ff
```

Using the `poi` command to deference a pointer:

```text
0:006> dd poi(esp)
77359bf9  c03307eb 658bc340 fc45c7e8 fffffffe
77359c09  e0e8006a ccfff98d cccccccc cccccccc
77359c19  cccccccc 8bcccccc ec8b55ff 180d8b64
77359c29  8b000000 81890845 00000f24 0004c25d
77359c39  cccccccc 8bcccccc ec8b55ff 0018a164
77359c49  b0ff0000 00000f24 e80875ff fffc49e7
77359c59  0004c25d cccccccc cccccccc cccccccc
77359c69  cccccccc 8bcccccc ec8b55ff 640875ff
```

### Dumping Structures from Memory

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/dt--display-type-

Symbol files use structures and structures are a programming concept that accepts user-defined data types that can combine different data items.

The Display Type `dt` command takes the name of the structure to display as an argument and, optionally, a memory address from which to dump the structure data. 
The structure needs to be provided by one of the loaded symbol files. 

The Thread Environment Block (or `TEB`) structure displayed in the example below is without any additional arguments:

```text
0:006> dt ntdll!_TEB
   +0x000 NtTib            : _NT_TIB
   +0x01c EnvironmentPointer : Ptr32 Void
   +0x020 ClientId         : _CLIENT_ID
   +0x028 ActiveRpcHandle  : Ptr32 Void
   +0x02c ThreadLocalStoragePointer : Ptr32 Void
   +0x030 ProcessEnvironmentBlock : Ptr32 _PEB
   +0x034 LastErrorValue   : Uint4B
   +0x038 CountOfOwnedCriticalSections : Uint4B
   +0x03c CsrClientThread  : Ptr32 Void
```

By supplying the -r flag to the `dt` command, WinDbg will recursively display nested structures where present:

```text
0:006> dt -r ntdll!_TEB @$teb
   +0x000 NtTib            : _NT_TIB
      +0x000 ExceptionList    : 0x00c3fcb4 _EXCEPTION_REGISTRATION_RECORD
         +0x000 Next             : 0x00c3fd10 _EXCEPTION_REGISTRATION_RECORD
         +0x004 Handler          : 0x77327390           _EXCEPTION_DISPOSITION  ntdll!_except_handler4+0
      +0x004 StackBase        : 0x00c40000 Void
      +0x008 StackLimit       : 0x00c3c000 Void
```

We can also display specific fields in the structure by passing the name of the field as an additional parameter:

```text
0:006> dt -r ntdll!_TEB @$teb DeallocationStack
   +0xe0c DeallocationStack : 0x00c00000 Void
```

WinDbg can also display the size of a structure extracted from a symbol file.
This is because some Windows APIs will take a structure as an argument, so we need to be able to determine the size in bytes of a certain structure.
To get this info, we use the WinDbg `sizeof` command:

```text
0:006> ?? sizeof(ntdll!_TEB)
unsigned int 0x1000
```

Displaying structures of the `PEB` along with their contents:

```text
0:006> dt -r ntdll!_PEB @$peb FlsCallback
   +0x20c FlsCallback : 0x0077e0f8 _FLS_CALLBACK_INFO
0:006> dd 0x0077e0f8
0077e0f8  00000000 00000000 77236200 00000000
0077e108  73dd16c0 00000000 00000000 00000000
0077e118  73da3bd0 00000000 77057490 00000000
0077e128  74d25000 00000000 00000000 00000000
```

Getting the structure from the given address:

```text
0:000> dt 7735bbcc
LdrpGetProcApphelpCheckModule
```

### Writing to Memory

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/e--ea--eb--ed--ed--ef--ep--eq--eu--ew--eza--ezu--enter-values-

The main WinDbg command for this job is `e*`, the edit command.

```text
0:000> dd esp L1
00a5f6a4  b2401093
0:000> dc esp L1
00a5f6a4  b2401093                             ..@.
0:000> ed esp 69736f73
0:000> dd esp L1
00a5f6a4  69736f73
0:000> dc esp L1
00a5f6a4  69736f73                             sosi
```

You can use `ea` for writing or modifying ASCII:

```text
0:000> ea esp "Hello friend"
0:000> dd esp L4
00a5f6a4  6c6c6548 7266206f 646e6569 00000000
0:000> dc esp L4
00a5f6a4  6c6c6548 7266206f 646e6569 00000000  Hello friend....
```

### Searching the Memory Space

To search the whole memory range, we use the `s` command and enter `L` and the value `?80000000`, which signifies the entire process's memory space. When searching for the memory type `DWORD`, we use -d.
Finally, we enter the pattern that we want to search for, in this case, `41414141`.

```text
0:000> dd esp L1
00a5f6a4  6c6c6548
0:000> ed esp 41414141
0:000> s -d 0 L?80000000 41414141
00a5f6a4  41414141 7266206f 646e6569 00000000  AAAAo friend....
68803820  41414141 db5e5e5e b6b7b7db b4b6b6b6  AAAA^^^
```

Searching for ASCII:

```text
s -a 0 L?80000000 "This program cannot be run in DOS mode"
```

```text
0:006> s -a 0x0 L?80000000 "w00tw00t"
```

Searching for Unicode:

```text
0:006> s -u 0x0 L?80000000 "w00tw00t"
02e994b0  0077 0030 0030 0074 0077 0030 0030 0074  w.0.0.t.w.0.0.t.
```

Searching for bytes:

```text
0:001> s -b 10000000 10223000 0xff 0xe4
10090c83  ff e4 0b 09 10 02 0c 09-10 24 0c 09 10 46 0c 09  .........$...F..
```

### Inspecting and Editing CPU Registers

Dump all the registers:

```text
0:000> r
eax=00000000 ebx=00000000 ecx=00a5f688 edx=77321670 esi=00996000 edi=772a36cc
eip=7735bb62 esp=00a5f6a4 ebp=00a5f6d0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!LdrpDoDebuggerBreak+0x2b:
7735bb62 7768            ja      ntdll!LdrpGetProcApphelpCheckModule+0x30 (7735bbcc) [br=0]
```

Modify `EAX` followed by the new register value:

```text
0:000> r eax=41414141
0:000> r
eax=41414141 ebx=00000000 ecx=00a5f688 edx=77321670 esi=00996000 edi=772a36cc
eip=7735bb62 esp=00a5f6a4 ebp=00a5f6d0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!LdrpDoDebuggerBreak+0x2b:
```

### Controlling the Program Execution

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/methods-of-controlling-breakpoints

WinDbg can set breakpoints to halt the execution flow at desired locations in the code. 

There are two different types of breakpoints

- software breakpoints - controlled directly by the debugger
- processor/hardware breakpoints - controlled by the processor and set through the debugger


#### Software Breakpoints

When placing a software breakpoint, WinDbg temporarily replaces the first opcode of the instruction where we want execution to halt with an `INT 3` assembly instruction. 

The advantage of software breakpoints is that we are allowed to set as many as we want.

We start by using `bp` along with the location where we want the application to stop

```text
0:000> bp kernel32!WriteFile
```

List all the breakpoints:

```text
0:000> bl
     0 e Disable Clear  74f0c6d0     0001 (0001)  0:**** KERNEL32!WriteFile
```

Let the execution continue:

```text
0:000> g
ModLoad: 75820000 75846000   C:\Windows\System32\IMM32.DLL
ModLoad: 728a0000 7291b000   C:\Windows\system32\uxtheme.dll
```

Disable a breakpoint:

```text
0:000> bd 0
```

Enable a breakpoint:

```text
0:000> be 0
```

Remove a breakpoint:

```text
0:000> bc 0
```

##### Unresolved Function Breakpoints

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/unresolved-breakpoints---bu-breakpoints-

We can use the `bu` command to set a breakpoint on an unresolved function.
This is a function residing in a module that isn't yet loaded in the process memory space. 

In this case, the breakpoint will be enabled when the module is loaded and the target function is resolved.

```text
0:006> lm m ole32
Browse full module list
start    end        module name
0:006> bu ole32!WriteStringStream
0:006> bl
     0 e Disable Clear u             0001 (0001) (ole32!WriteStringStream)
```

#### Breakpoint-Based Actions

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/command-tokens

We can also automate the execution of commands within the debugger when a breakpoint is triggered.
This enables us to print the register's content, dereference memory locations, and perform other powerful actions when a breakpoint is hit.

```text
bp kernel32!WriteFile ".printf \"suda podoshel\""
```

This prints a number of bytes written to a file:

```text
0:000> bp kernel32!WriteFile ".printf \"The number of bytes saved is %p\", poi(esp + 0x0c);.echo;g"
breakpoint 0 redefined
0:000> g
The number of bytes saved is 00000007
```

- https://en.wikipedia.org/wiki/Printf_format_string

Similar to the C/C++ version, `.printf` supports the use of format strings such as `%p`, which will display the given value as a pointer. 
In our example, the `.echo` command displays the output of `.printf` to the WinDbg command window. 
The semi-colon (;) delimiter separates multiple commands assigned to a single breakpoint and executes them in the order listed.

In our case, we chose to display the value pointed to by the `ESP` register at offset `0x0C` (12 bytes), which corresponds to the number of bytes to write to the target file (third argument) when `kernel32!WriteFile` is called.

This is defined in the `WriteFile` prototype:

```text
BOOL WriteFile(
  HANDLE       hFile,
  LPCVOID      lpBuffer,
  DWORD        nNumberOfBytesToWrite,
  LPDWORD      lpNumberOfBytesWritten,
  LPOVERLAPPED lpOverlapped
);
```

This is because the Windows x86 API makes use of the `__stdcall` calling convention in which the function arguments are pushed on the stack in reverse order (right to left).
In this case, each argument occupies four bytes of memory on the stack.

#### Conditional Breakpoints

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/pseudo-register-syntax

Using `.if` and `.else` statements:

```text
0:000> bp kernel32!WriteFile ".if (poi(esp + 0x0c) != 4) {gc} .else {.printf \"The number of bytes saved is 4\";.echo;g}"
```

When our breakpoint on `WriteFile` is triggered, we use `gc` (go from conditional breakpoint) to resume execution, unless the `nNumberOfBytesToWrite` argument (third argument on the stack) is equal to "4".

This command will halt the execution of a program when the breakpoint is triggered using the same conditions:

```text
0:000> bp kernel32!WriteFile ".if (poi(esp + 0x0c) != 4) {gc} .else {.printf \"w00t w00t\"; .echo;}"
```

Halt the execution when the value of the `ESI` register equals to `4`:

```text
0:000> bp kernel32!WriteFile ".if (@esi == 4) { .echo \"you just made it\"} .else {gc}"
0:000> g
you just made it
eax=02d1eb50 ebx=031b0f80 ecx=4041f2b5 edx=031b0f88 esi=00000004 edi=08184728
eip=74f0c6d0 esp=02d1eb30 ebp=02d1eb64 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
KERNEL32!WriteFile:
74f0c6d0 ff259044f674    jmp     dword ptr [KERNEL32!_imp__WriteFile (74f64490)] ds:0023:74f64490={KERNELBASE!WriteFile (73f9b160)}
```

#### Hardware Breakpoints

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/processor-breakpoints---ba-breakpoints-

Hardware or processor breakpoints are handled by the processor and stored in the processor's debug registers.
They can stop code execution when a particular type of access, such as read, write, or execute, is made to a targeted memory location.

The primary advantage of hardware breakpoints is that they provide the ability to monitor changes or access to data in memory. This can be a time saver when we reverse engineer code.
However, the x86 and x64 architectures only use four debug registers, so unlike software breakpoints, we are limited by the number of processor breakpoints.

To set a hardware breakpoint in WinDbg, we need to pass three arguments to the `ba` command. 
- the first is the type of access, which can be either `e` (execute), `r` (read), or `w` (write)
- the second one is the size in bytes for the specified memory access
- the third argument is the memory address where we want to set the breakpoint at

Setting a hardware breakpoint on the execution of the `WriteFile` API:

```text
0:000> ba e 1 kernel32!WriteFile
```
Setting a hardware breakpoint on writing of the first two bytes to the specified memory location:

```text
0:000> ba w 2 03b2c768
```

#### Stepping Through the Code

We can use `p` and `t` to step over, and into each instruction, respectively.

Specifically, the `p` command will execute one single instruction at a time and **steps over** function calls, and `t` will do the same, but will also **step into** function calls.

Another convenient command is `pt` (step to next return), which allows us to fast-forward to the end of a function.

Like the `pt` command, `ph` executes code until a branching instruction is reached. This includes conditional or unconditional branches, function calls, and return instructions.

### Listing Loaded Modules

Get a list of loaded modules:

```text
0:001> lm
start    end        module name
00c50000 00c8f000   notepad    (pdb symbols)          c:\symbols\notepad.pdb\FB4FCA58AFCC3ACA154240CE7B7A58131\notepad.pdb
596f0000 5985f000   DUI70      (deferred)             
```

Filtering by the module name:

```text
0:001> lm m kernel*
start    end        module name
73d70000 73d7e000   kernel_appcore   (pdb symbols)          c:\symbols\Kernel.Appcore.pdb\E809C8B1302B9976E49A0476E5D627491\Kernel.Appcore.pdb
73ec0000 74098000   KERNELBASE   (pdb symbols)          c:\symbols\kernelbase.pdb\13D9C53AB6F8551B30ABB78D4F9A1F8A1\kernelbase.pdb
74ee0000 74f75000   KERNEL32   (pdb symbols)          c:\symbols\kernel32.pdb\EFA698598E9A5A3CB89EC02E7DE288041\kernel32.pdb
```

### Using WinDbg as Calculator

Mathematical calculations are performed by the evaluate expression command, `?`. 
We often have to perform tasks such as finding the difference between two addresses or finding lower or upper byte values of a `DWORD`. 

WinDbg easily solves this, as shown here:

```text
0:007> ? 77269bc0  - 77231430 
Evaluate expression: 231312 = 00038790

0:007> ? 77269bc0 >> 18
Evaluate expression: 119 = 00000077
```

### Data Output Formats

By default, WinDbg displays content in hexadecimal format. However, sometimes we will need data in a different form.
Fortunately, we can convert the hex representation to decimal or binary format. We can do this with the 0n and 0y prefixes respectively. We can observe some conversion examples shown below using the evaluate expression command ?.

```text
0:000> ? 41414141
Evaluate expression: 1094795585 = 41414141

0:000> ? 0n41414141
Evaluate expression: 41414141 = 0277edfd

0:000> ? 0y1110100110111
Evaluate expression: 7479 = 00001d37
```

Here we convert the hex number `41414141` to decimal, then convert the decimal number `0n41414141` to hexadecimal, and finally we convert the binary `0y1110100110111` to decimal and hexadecimal.

The `.formats` command is also useful for converting between different formats at once, including the ASCII representation of the value as shown below.

```text
0:000> .formats 41414141
Evaluate expression:
  Hex:     41414141
  Decimal: 1094795585
  Octal:   10120240501
  Binary:  01000001 01000001 01000001 01000001
  Chars:   AAAA
  Time:    Fri Sep 10 07:53:05 2004
  Float:   low 12.0784 high 0
  Double:  5.40901e-315
```

### Pseudo Registers

Sometimes we have to perform complicated calculations when reverse engineering or developing an exploit. A somewhat complicated fictitious calculation is shown below.

```text
0:000> ? ((41414141 - 414141) * 0n10) >> 8
Evaluate expression: 42598400 = 028a0000
```

The same calculation can be performed with a pseudo register. 

Here we use the `$t0` pseudo register and store the value of the first calculation. 
Then we read the `$t0` register and WinDbg outputs the result to verify the value. 

Finally, we right-shift `$t0` by 8 bits to get the final result. This process is shown below.

```text
0:000> r @$t0 = (41414141 - 414141) * 0n10

0:000> r @$t0
$t0=8a000000*

0:000> ? @$t0 >> 8
Evaluate expression: 42598400 = 028a0000
```

Pseudo registers allow us to store values or split up computations, and we'll use them in later modules.


### Attaching to Process from Command-Line

An example of attaching to a process by passing a command-line argument to WinDbg:

```bash
"C:\Program Files\Windows Kits\10\Debuggers\x86\windbg.exe" -WF C:\windbg_custom.WEW -pn notepad.exe
```
