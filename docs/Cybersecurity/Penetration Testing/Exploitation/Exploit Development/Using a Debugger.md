## Using a Debugger

A debugger is a computer program inserted between the target application and the CPU, in principle, acting like a proxy.

Using a debugger allows us to view and interact with the memory and execution flow of applications.
The memory space of most operation systems, including Windows, is divided into two parts, kernel mode (ring 0) and user mode (ring 3).

## Debugging Symbols

Symbol files permit to reference internal functions, structures, and global variables using names instead of addresses.

## Using WinDBG

- https://developer.microsoft.com/en-us/windows/hardware/download-windbg
- https://docs.microsoft.com/en-gb/windows-hardware/drivers/debugger/debugging-using-windbg-preview

We access the symbol settings through the `File > Symbol File Path...` menu. A commonly used symbol path is `C:\symbols`.

```text
srv*c:\symbols*https://msdl.microsoft.com/download/symbols
```

Reload current modules:

```text
0:006> .reload /f
```

### Unassemble from memory:

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/u--unassemble-

We can display the assembly translation of a specified program code in memory with the WinDbg `u1` command. 
This is useful as it allows us to inspect the assembly code of certain Windows APIs as well as any part of the code of the current running program.

```text
0:006> u kernel32!GetCurrentThread
KERNEL32!GetCurrentThread:
74f02620 b8feffffff      mov     eax,0FFFFFFFEh
74f02625 c3              ret
74f02626 cc              int     3
74f02627 cc              int     3
74f02628 cc              int     3
74f02629 cc              int     3
74f0262a cc              int     3
74f0262b cc              int     3
```

### Reading from Memory

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/d--da--db--dc--dd--dd--df--dp--dq--du--dw--dw--dyb--dyd--display-memor

We can read process memory content using the `display` command followed by the size indicator.

Display bytes through the `db` command (this uses the ESP register instead of an explicit memory address):

```text
0:006> db esp
0703fa70  f9 9b 35 77 14 38 a2 4e-c0 9b 35 77 c0 9b 35 77  ..5w.8.N..5w..5w
0703fa80  00 00 00 00 74 fa 03 07-00 00 00 00 e8 fa 03 07  ....t...........
0703fa90  90 73 32 77 c8 f9 98 3e-00 00 00 00 b0 fa 03 07  .s2w...>........
0703faa0  64 95 ef 74 00 00 00 00-40 95 ef 74 1b f3 6e de  d..t....@..t..n.
0703fab0  f8 fa 03 07 3c 29 2f 77-00 00 00 00 70 38 a2 4e  ....<)/w....p8.N
0703fac0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
0703fad0  00 00 00 00 00 00 00 00-00 00 00 00 70 38 a2 4e  ............p8.N
0703fae0  bc fa 03 07 00 00 00 00-00 fb 03 07 90 73 32 77  .............s2w
```

Display bytes located at the given address:

```text
0:006> db 0703fae0
0703fae0  bc fa 03 07 00 00 00 00-00 fb 03 07 90 73 32 77  .............s2w
0703faf0  b8 ed 98 3e 00 00 00 00-08 fb 03 07 10 29 2f 77  ...>.........)/w
0703fb00  ff ff ff ff 61 3c 33 77-00 00 00 00 00 00 00 00  ....a<3w........
0703fb10  c0 9b 35 77 00 00 00 00-00 00 00 00 00 00 00 00  ..5w............
0703fb20  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
```

To display data in a larger size format we can use `dw` (WORDs, two bytes together):

```text
0:006> dw esp
0703fa70  9bf9 7735 3814 4ea2 9bc0 7735 9bc0 7735
0703fa80  0000 0000 fa74 0703 0000 0000 fae8 0703
0703fa90  7390 7732 f9c8 3e98 0000 0000 fab0 0703
0703faa0  9564 74ef 0000 0000 9540 74ef f31b de6e
0703fab0  faf8 0703 293c 772f 0000 0000 3870 4ea2
0703fac0  0000 0000 0000 0000 0000 0000 0000 0000
0703fad0  0000 0000 0000 0000 0000 0000 3870 4ea2
0703fae0  fabc 0703 0000 0000 fb00 0703 7390 7732
```

To display DWORDs (four bytes) you can use `dd`:

```text
0:006> dd esp
0703fa70  77359bf9 4ea23814 77359bc0 77359bc0
0703fa80  00000000 0703fa74 00000000 0703fae8
0703fa90  77327390 3e98f9c8 00000000 0703fab0
0703faa0  74ef9564 00000000 74ef9540 de6ef31b
0703fab0  0703faf8 772f293c 00000000 4ea23870
0703fac0  00000000 00000000 00000000 00000000
0703fad0  00000000 00000000 00000000 4ea23870
0703fae0  0703fabc 00000000 0703fb00 77327390
```

Change default length when displaying data:

```text
0:006> dd esp L4
0703fa70  77359bf9 4ea23814 77359bc0 77359bc0

0:006> dd esp L10
0703fa70  77359bf9 4ea23814 77359bc0 77359bc0
0703fa80  00000000 0703fa74 00000000 0703fae8
0703fa90  77327390 3e98f9c8 00000000 0703fab0
0703faa0  74ef9564 00000000 74ef9540 de6ef31b
```

To display QWORDs (eight bytes), we can use `dq`:

```text
0:006> dq esp
0703fa70  4ea23814`77359bf9 77359bc0`77359bc0
0703fa80  0703fa74`00000000 0703fae8`00000000
0703fa90  3e98f9c8`77327390 0703fab0`00000000
0703faa0  00000000`74ef9564 de6ef31b`74ef9540
0703fab0  772f293c`0703faf8 4ea23870`00000000
0703fac0  00000000`00000000 00000000`00000000
0703fad0  00000000`00000000 4ea23870`00000000
0703fae0  00000000`0703fabc 77327390`0703fb00
```

To display memory content in ASCII we can use `dc` or `dW`:

```text
0:006> dc KERNELBASE
73ec0000  00905a4d 00000003 00000004 0000ffff  MZ..............
73ec0010  000000b8 00000000 00000040 00000000  ........@.......
73ec0020  00000000 00000000 00000000 00000000  ................
73ec0030  00000000 00000000 00000000 000000f0  ................
73ec0040  0eba1f0e cd09b400 4c01b821 685421cd  ........!..L.!Th
73ec0050  70207369 72676f72 63206d61 6f6e6e61  is program canno
73ec0060  65622074 6e757220 206e6920 20534f44  t be run in DOS 
73ec0070  65646f6d 0a0d0d2e 00000024 00000000  mode....$.......
0:006> dW KERNELBASE+0x40
73ec0040  1f0e 0eba b400 cd09 b821 4c01 21cd 6854  ........!..L.!Th
73ec0050  7369 7020 6f72 7267 6d61 6320 6e61 6f6e  is program canno
73ec0060  2074 6562 7220 6e75 6920 206e 4f44 2053  t be run in DOS 
73ec0070  6f6d 6564 0d2e 0a0d 0024 0000 0000 0000  mode....$.......
73ec0080  257d 47ae 4439 14c0 4439 14c0 4439 14c0  }%.G9D..9D..9D..
73ec0090  3c30 1453 443d 14c0 4439 14c1 475e 14c0  0<S.=D..9D..^G..
73ec00a0  264a 15c1 443c 14c0 264a 15c5 4429 14c0  J&..<D..J&..)D..
73ec00b0  264a 15c3 4431 14c0 264a 15c4 475c 14c0  J&..1D..J&..\G..
0:006> dW KERNELBASE L5
73ec0000  5a4d 0090 0003 0000 0004                 MZ........
```

Using the `dd` command twice to deference a pointer:

```text
0:006> dd esp L1
0703fa70  77359bf9
0:006> dd 77359bf9
77359bf9  c03307eb 658bc340 fc45c7e8 fffffffe
77359c09  e0e8006a ccfff98d cccccccc cccccccc
77359c19  cccccccc 8bcccccc ec8b55ff 180d8b64
77359c29  8b000000 81890845 00000f24 0004c25d
77359c39  cccccccc 8bcccccc ec8b55ff 0018a164
77359c49  b0ff0000 00000f24 e80875ff fffc49e7
77359c59  0004c25d cccccccc cccccccc cccccccc
77359c69  cccccccc 8bcccccc ec8b55ff 640875ff
```

Using the `poi` command to deference a pointer:

```text
0:006> dd poi(esp)
77359bf9  c03307eb 658bc340 fc45c7e8 fffffffe
77359c09  e0e8006a ccfff98d cccccccc cccccccc
77359c19  cccccccc 8bcccccc ec8b55ff 180d8b64
77359c29  8b000000 81890845 00000f24 0004c25d
77359c39  cccccccc 8bcccccc ec8b55ff 0018a164
77359c49  b0ff0000 00000f24 e80875ff fffc49e7
77359c59  0004c25d cccccccc cccccccc cccccccc
77359c69  cccccccc 8bcccccc ec8b55ff 640875ff
```

### Dumping Structures from Memory

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/dt--display-type-

Symbol files use structures and structures are a programming concept that accepts user-defined data types that can combine different data items.

The Display Type `dt` command takes the name of the structure to display as an argument and, optionally, a memory address from which to dump the structure data. 
The structure needs to be provided by one of the loaded symbol files. 

The Thread Environment Block (or `TEB`) structure displayed in the example below is without any additional arguments:

```text
0:006> dt ntdll!_TEB
   +0x000 NtTib            : _NT_TIB
   +0x01c EnvironmentPointer : Ptr32 Void
   +0x020 ClientId         : _CLIENT_ID
   +0x028 ActiveRpcHandle  : Ptr32 Void
   +0x02c ThreadLocalStoragePointer : Ptr32 Void
   +0x030 ProcessEnvironmentBlock : Ptr32 _PEB
   +0x034 LastErrorValue   : Uint4B
   +0x038 CountOfOwnedCriticalSections : Uint4B
   +0x03c CsrClientThread  : Ptr32 Void
```

By supplying the -r flag to the `dt` command, WinDbg will recursively display nested structures where present:

```text
0:006> dt -r ntdll!_TEB @$teb
   +0x000 NtTib            : _NT_TIB
      +0x000 ExceptionList    : 0x00c3fcb4 _EXCEPTION_REGISTRATION_RECORD
         +0x000 Next             : 0x00c3fd10 _EXCEPTION_REGISTRATION_RECORD
         +0x004 Handler          : 0x77327390           _EXCEPTION_DISPOSITION  ntdll!_except_handler4+0
      +0x004 StackBase        : 0x00c40000 Void
      +0x008 StackLimit       : 0x00c3c000 Void
```

We can also display specific fields in the structure by passing the name of the field as an additional parameter:

```text
0:006> dt -r ntdll!_TEB @$teb DeallocationStack
   +0xe0c DeallocationStack : 0x00c00000 Void
```

WinDbg can also display the size of a structure extracted from a symbol file.
This is because some Windows APIs will take a structure as an argument, so we need to be able to determine the size in bytes of a certain structure.
To get this info, we use the WinDbg `sizeof` command:

```text
0:006> ?? sizeof(ntdll!_TEB)
unsigned int 0x1000
```

Displaying structures of the `PEB` along with their contents:

```text
0:006> dt -r ntdll!_PEB @$peb FlsCallback
   +0x20c FlsCallback : 0x0077e0f8 _FLS_CALLBACK_INFO
0:006> dd 0x0077e0f8
0077e0f8  00000000 00000000 77236200 00000000
0077e108  73dd16c0 00000000 00000000 00000000
0077e118  73da3bd0 00000000 77057490 00000000
0077e128  74d25000 00000000 00000000 00000000
```

Getting the structure from the given address:

```text
0:000> dt 7735bbcc
LdrpGetProcApphelpCheckModule
```

### Writing to Memory

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/e--ea--eb--ed--ed--ef--ep--eq--eu--ew--eza--ezu--enter-values-

The main WinDbg command for this job is `e*`, the edit command.

```text
0:000> dd esp L1
00a5f6a4  b2401093
0:000> dc esp L1
00a5f6a4  b2401093                             ..@.
0:000> ed esp 69736f73
0:000> dd esp L1
00a5f6a4  69736f73
0:000> dc esp L1
00a5f6a4  69736f73                             sosi
```

You can use `ea` for writing or modifying ASCII:

```text
0:000> ea esp "Hello friend"
0:000> dd esp L4
00a5f6a4  6c6c6548 7266206f 646e6569 00000000
0:000> dc esp L4
00a5f6a4  6c6c6548 7266206f 646e6569 00000000  Hello friend....
```

### Searching the Memory Space

To search the whole memory range, we use the `s` command and enter `L` and the value `?80000000`, which signifies the entire process's memory space. When searching for the memory type `DWORD`, we use -d.
Finally, we enter the pattern that we want to search for, in this case, `41414141`.

```text
0:000> dd esp L1
00a5f6a4  6c6c6548
0:000> ed esp 41414141
0:000> s -d 0 L?80000000 41414141
00a5f6a4  41414141 7266206f 646e6569 00000000  AAAAo friend....
68803820  41414141 db5e5e5e b6b7b7db b4b6b6b6  AAAA^^^
```

```text
s -a 0 L?80000000 "This program cannot be run in DOS mode"
```

### Inspecting and Editing CPU Registers

Dump all the registers:

```text
0:000> r
eax=00000000 ebx=00000000 ecx=00a5f688 edx=77321670 esi=00996000 edi=772a36cc
eip=7735bb62 esp=00a5f6a4 ebp=00a5f6d0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!LdrpDoDebuggerBreak+0x2b:
7735bb62 7768            ja      ntdll!LdrpGetProcApphelpCheckModule+0x30 (7735bbcc) [br=0]
```

Modify `EAX` followed by the new register value:

```text
0:000> r eax=41414141
0:000> r
eax=41414141 ebx=00000000 ecx=00a5f688 edx=77321670 esi=00996000 edi=772a36cc
eip=7735bb62 esp=00a5f6a4 ebp=00a5f6d0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!LdrpDoDebuggerBreak+0x2b:
```

### Controlling the Program Execution

- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/methods-of-controlling-breakpoints

WinDbg can set breakpoints to halt the execution flow at desired locations in the code. 

There are two different types of breakpoints

- software breakpoints - controlled directly by the debugger
- processor/hardware breakpoints - controlled by the processor and set through the debugger


#### Software Breakpoints

When placing a software breakpoint, WinDbg temporarily replaces the first opcode of the instruction where we want execution to halt with an `INT 3` assembly instruction. 

The advantage of software breakpoints is that we are allowed to set as many as we want.

We start by using `bp` along with the location where we want the application to stop

```text
0:000> bp kernel32!WriteFile
```

List all the breakpoints:

```text
0:000> bl
     0 e Disable Clear  74f0c6d0     0001 (0001)  0:**** KERNEL32!WriteFile
```

Let the execution continue:

```text
0:000> g
ModLoad: 75820000 75846000   C:\Windows\System32\IMM32.DLL
ModLoad: 728a0000 7291b000   C:\Windows\system32\uxtheme.dll
```

#### Hardware Breakpoints


