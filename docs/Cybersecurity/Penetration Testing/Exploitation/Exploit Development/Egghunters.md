## General Information

In some cases, a vulnerability only provides us with a very small buffer that we can use after a memory corruption. 
In such cases, it can be difficult for the attacker to reliably position a larger payload at a predictable location in memory.

Sometimes, depending on the vulnerability or application, it's possible to store a larger payload somewhere else in the address space of the process. 
In a situation like this, the egghunter technique may be an effective exploitation methodology.


In other words, if we can store a second, larger buffer elsewhere, we can use our current, smaller buffer space to write a `stage one` shellcode.
The purpose of this shellcode would be to redirect the execution flow to that second buffer, where we will have more space to store a larger payload.

To determine what will be stored in memory by our vulnerable application, we could either perform a very in-depth reverse engineering process on the application, which is out of the scope of this module, or we could make some educated guesses based on the type of application we are attacking.

## The Egghunter Approach

- http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf

When we need to find the memory address of another buffer under our control that is not static, we often use an `Egghunter`.
This term refers to a small first-stage payload that can search the process virtual address space (`VAS`) for an `egg`, a unique tag that prepends the payload we want to execute. 
Once the `eg`g is found, the `egghunter` transfers the execution to the final shellcode by jumping to the found address. 
One of the first implementations of this technique can be found in a paper written by Matt Miller in 2004.

Since `egghunters` are often used when dealing with space restrictions, they are written to be as small as possible. Additionally, the speed of the `egghunter` is essential; the faster the `egghunter` finds the unique tag, the less time the application will hang.

These type of payloads also need to be robust and handle access violations that are raised while scanning the virtual address space. 
The access violations usually occur while attempting to access an unmapped memory address or addresses we don't have access to.

In the past, we would typically write the assembly code for our egghunter and then proceed to compile the code. After, we would disassemble the compiled binary in software such as IDA to get the opcodes for it.
Fortunately, we have a better alternative.



